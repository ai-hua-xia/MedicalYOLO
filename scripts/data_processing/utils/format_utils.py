from typing import List, Dict, Any, Optional, Union
from pathlib import Path
import csv
import json
import yaml

def read_json_file(file_path, encoding='utf-8'):
    with open(file_path, 'r', encoding=encoding) as f:
        return json.load(f)

def write_json_file(data, file_path, encoding='utf-8'):
    with open(file_path, 'w', encoding=encoding) as f:
        json.dump(data, f, ensure_ascii=False, indent=2)

def read_yaml_file(file_path, encoding='utf-8'):
    with open(file_path, 'r', encoding=encoding) as f:
        return yaml.safe_load(f)

def write_yaml_file(data, file_path, encoding='utf-8'):
    with open(file_path, 'w', encoding=encoding) as f:
        yaml.safe_dump(data, f, allow_unicode=True)

def read_classes_file(file_path, encoding='utf-8'):
    with open(file_path, 'r', encoding=encoding) as f:
        return [line.strip() for line in f if line.strip()]

def write_classes_file(classes, file_path, encoding='utf-8'):
    with open(file_path, 'w', encoding=encoding) as f:
        for cls in classes:
            f.write(f"{cls}\n")

def read_yolo_annotation(file_path: str, encoding: str = 'utf-8') -> List[List[float]]:
    """
    读取YOLO格式标注文件
    
    Args:
        file_path: 标注文件路径
        encoding: 文件编码
        
    Returns:
        标注列表，每个标注为 [class_id, x_center, y_center, width, height]
    """
    annotations = []
    try:
        with open(file_path, 'r', encoding=encoding) as f:
            for line in f:
                line = line.strip()
                if line:
                    parts = line.split()
                    if len(parts) >= 5:
                        annotation = [float(parts[0])] + [float(x) for x in parts[1:5]]
                        annotations.append(annotation)
    except Exception as e:
        raise IOError(f"无法读取YOLO标注文件 {file_path}: {e}")
    
    return annotations

def write_yolo_annotation(annotations: List[List[float]], 
                         file_path: str, 
                         encoding: str = 'utf-8') -> None:
    """
    写入YOLO格式标注文件
    
    Args:
        annotations: 标注列表
        file_path: 输出文件路径
        encoding: 文件编码
    """
    try:
        Path(file_path).parent.mkdir(parents=True, exist_ok=True)
        with open(file_path, 'w', encoding=encoding) as f:
            for annotation in annotations:
                class_id = int(annotation[0])
                bbox = annotation[1:5]
                line = f"{class_id} {' '.join(map(str, bbox))}\n"
                f.write(line)
    except Exception as e:
        raise IOError(f"无法写入YOLO标注文件 {file_path}: {e}")

def convert_bbox_format(bbox: List[float], 
                       from_format: str, 
                       to_format: str, 
                       img_width: int, 
                       img_height: int) -> List[float]:
    """
    转换边界框格式
    
    Args:
        bbox: 边界框坐标
        from_format: 源格式 ('xyxy', 'xywh', 'cxcywh')
        to_format: 目标格式 ('xyxy', 'xywh', 'cxcywh')
        img_width: 图像宽度
        img_height: 图像高度
        
    Returns:
        转换后的边界框
    """
    # 首先转换为xyxy格式（绝对坐标）
    if from_format == 'xyxy':
        x1, y1, x2, y2 = bbox
    elif from_format == 'xywh':
        x, y, w, h = bbox
        x1, y1, x2, y2 = x, y, x + w, y + h
    elif from_format == 'cxcywh':
        cx, cy, w, h = bbox
        # 如果是归一化坐标，转换为绝对坐标
        if cx <= 1 and cy <= 1 and w <= 1 and h <= 1:
            cx *= img_width
            cy *= img_height
            w *= img_width
            h *= img_height
        x1 = cx - w / 2
        y1 = cy - h / 2
        x2 = cx + w / 2
        y2 = cy + h / 2
    else:
        raise ValueError(f"不支持的源格式: {from_format}")
    
    # 转换为目标格式
    if to_format == 'xyxy':
        return [x1, y1, x2, y2]
    elif to_format == 'xywh':
        return [x1, y1, x2 - x1, y2 - y1]
    elif to_format == 'cxcywh':
        cx = (x1 + x2) / 2
        cy = (y1 + y2) / 2
        w = x2 - x1
        h = y2 - y1
        # 归一化
        return [cx / img_width, cy / img_height, w / img_width, h / img_height]
    else:
        raise ValueError(f"不支持的目标格式: {to_format}")

def create_coco_annotation_template() -> Dict[str, Any]:
    """创建COCO标注格式模板"""
    return {
        "info": {
            "description": "Generated by MedicalYOLO",
            "version": "1.0",
            "year": 2024,
            "contributor": "MedicalYOLO",
            "date_created": ""
        },
        "licenses": [
            {
                "id": 1,
                "name": "Unknown",
                "url": ""
            }
        ],
        "images": [],
        "categories": [],
        "annotations": []
    }

def read_csv_file(file_path: str, encoding: str = 'utf-8') -> List[Dict[str, Any]]:
    """
    读取CSV文件
    
    Args:
        file_path: CSV文件路径
        encoding: 文件编码
        
    Returns:
        数据列表
    """
    data = []
    try:
        with open(file_path, 'r', encoding=encoding, newline='') as f:
            reader = csv.DictReader(f)
            for row in reader:
                data.append(dict(row))
    except Exception as e:
        raise IOError(f"无法读取CSV文件 {file_path}: {e}")
    
    return data

def write_csv_file(data: List[Dict[str, Any]], 
                  file_path: str, 
                  fieldnames: Optional[List[str]] = None,
                  encoding: str = 'utf-8') -> None:
    """
    写入CSV文件
    
    Args:
        data: 要写入的数据
        file_path: 输出文件路径
        fieldnames: 字段名列表
        encoding: 文件编码
    """
    if not data:
        return
    
    if fieldnames is None:
        fieldnames = list(data[0].keys())
    
    try:
        Path(file_path).parent.mkdir(parents=True, exist_ok=True)
        with open(file_path, 'w', encoding=encoding, newline='') as f:
            writer = csv.DictWriter(f, fieldnames=fieldnames)
            writer.writeheader()
            writer.writerows(data)
    except Exception as e:
        raise IOError(f"无法写入CSV文件 {file_path}: {e}")

def normalize_path(path: Union[str, Path]) -> str:
    """
    标准化路径格式
    
    Args:
        path: 输入路径
        
    Returns:
        标准化后的路径字符串
    """
    return str(Path(path).resolve())

def get_file_extension(file_path: str) -> str:
    """
    获取文件扩展名
    
    Args:
        file_path: 文件路径
        
    Returns:
        文件扩展名（小写，包含点）
    """
    return Path(file_path).suffix.lower()

def is_image_file(file_path: str, 
                 supported_extensions: List[str] = None) -> bool:
    """
    检查是否为支持的图像文件
    
    Args:
        file_path: 文件路径
        supported_extensions: 支持的扩展名列表
        
    Returns:
        是否为图像文件
    """
    if supported_extensions is None:
        supported_extensions = ['.jpg', '.jpeg', '.png', '.bmp', '.tiff', '.webp']
    
    ext = get_file_extension(file_path)
    return ext in supported_extensions

def format_file_size(size_bytes: int) -> str:
    """
    格式化文件大小显示
    
    Args:
        size_bytes: 文件大小（字节）
        
    Returns:
        格式化后的大小字符串
    """
    if size_bytes == 0:
        return "0 B"
    
    size_names = ["B", "KB", "MB", "GB", "TB"]
    i = 0
    size = float(size_bytes)
    
    while size >= 1024.0 and i < len(size_names) - 1:
        size /= 1024.0
        i += 1
    
    return f"{size:.1f} {size_names[i]}"